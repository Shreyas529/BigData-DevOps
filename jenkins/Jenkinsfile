pipeline {
    agent any
    
    triggers {
        // Poll SCM every 5 minutes for changes
        // pollSCM('H/5 * * * *')
        // Or use GitHub webhook (recommended)
        githubPush()
    }
    
    environment {
        DOCKER_HUB_CREDENTIALS = 'dockerhub-creds'
        IMAGE_NAME = 'siddharth194/bigdata-devops'
        BACKEND_TAG = 'backend'
        FRONTEND_TAG = 'frontend'
    }
    
    stages {
        stage('Cleanup Previous') {
            steps {
                script {
                    sh '''
                        # Stop compose project and prune test state
                        docker-compose -p test down -v || true

                        echo "Removing old images for ${IMAGE_NAME} (frontend/backend tags)..."

                        # Remove previous frontend images: ${IMAGE_NAME}:frontend-*
                        docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' \
                          | awk -v repo="${IMAGE_NAME}" -v prefix="${FRONTEND_TAG}-" '$1 ~ (repo ":" prefix) {print $2}' \
                          | xargs -r docker rmi -f || true

                        # Remove previous backend images: ${IMAGE_NAME}:backend-*
                        docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' \
                          | awk -v repo="${IMAGE_NAME}" -v prefix="${BACKEND_TAG}-" '$1 ~ (repo ":" prefix) {print $2}' \
                          | xargs -r docker rmi -f || true

                        # Cleanup dangling images only (safe for Minikube)
                        docker image prune -f || true
                    '''
                }
            }
        }
        
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // Print current directory and list files
                    sh '''
                        echo "Current directory: $(pwd)"
                        echo "Files in workspace:"
                        ls -la
                        echo "Files in k8s directory:"
                        ls -la k8s/ || echo "k8s directory not found"
                    '''
                }
            }
        }

        // stage('Run Tests') {
        //     steps {
        //         script {
        //             sh '''
        //                 docker-compose -f docker-compose.test.yml \
        //                     -p test \
        //                     up --build --abort-on-container-exit --exit-code-from test_runner
        //             '''
        //         }
        //     }
        // }

        stage('Build Images') {
            steps {
                script {
                    sh """
                        echo "Building Frontend Image..."
                        docker build -t ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER} ./frontend

                        echo "Building Backend Image..."
                        docker build -t ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER} ./backend
                    """
                }
            }
        }

        stage('Push to DockerHub') {
            steps {
                script {
                    withCredentials([usernamePassword(
                        credentialsId: DOCKER_HUB_CREDENTIALS,
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {
                        sh """
                            echo \${DOCKER_PASS} | docker login -u \${DOCKER_USER} --password-stdin
                            
                            echo "Pushing Frontend Image..."
                            docker push ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}

                            echo "Pushing Backend Image..."
                            docker push ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}

                            docker logout
                        """
                    }
                }
            }
        }

        stage('Pull Images from DockerHub') {
            steps {
                script {
                    sh """
                        docker pull ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}
                        docker pull ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}
                    """
                }
            }
        }

        // stage('Update Kubernetes Manifests') {
        //     steps {
        //         script {
        //             sh """
        //                 # Verify we're in the right directory
        //                 echo "Current working directory: \$(pwd)"
        //                 echo "Checking for k8s directory..."
                        
        //                 if [ ! -d "k8s" ]; then
        //                     echo "ERROR: k8s directory not found!"
        //                     echo "Contents of current directory:"
        //                     ls -la
        //                     exit 1
        //                 fi
                        
        //                 # Update image tags in Kubernetes manifests
        //                 echo "Updating backend-deployment.yaml..."
        //                 sed -i 's|image: ${IMAGE_NAME}:${BACKEND_TAG}-[0-9]*|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g' k8s/backend-deployment.yaml
                        
        //                 echo "Updating frontend-deployment.yaml..."
        //                 sed -i 's|image: ${IMAGE_NAME}:${FRONTEND_TAG}-[0-9]*|image: ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}|g' k8s/frontend-deployment.yaml
                        
        //                 echo "Updating consumer-deployment.yaml..."
        //                 sed -i 's|image: ${IMAGE_NAME}:${BACKEND_TAG}-[0-9]*|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g' k8s/consumer-deployment.yaml
                        
        //                 echo "Updating db-init-job.yaml..."
        //                 sed -i 's|image: ${IMAGE_NAME}:${BACKEND_TAG}-[0-9]*|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g' k8s/db-init-job.yaml
                        
        //                 echo "Updated manifests with build number: ${BUILD_NUMBER}"
                        
        //                 # Show what changed
        //                 echo "=== Verification: Image tags in manifests ==="
        //                 grep -n "image:" k8s/backend-deployment.yaml k8s/frontend-deployment.yaml k8s/consumer-deployment.yaml k8s/db-init-job.yaml || true
        //             """
        //         }
        //     }
        // }

        stage('Update Kubernetes Manifests') {
            steps {
                script {
                    sh """
                        # Verify we're in the right directory
                        echo "Current working directory: \$(pwd)"
                        echo "Checking for k8s directory..."
                        
                        if [ ! -d "k8s" ]; then
                            echo "ERROR: k8s directory not found!"
                            echo "Contents of current directory:"
                            ls -la
                            exit 1
                        fi
                        
                        # Update image tags in Kubernetes manifests (Linux compatible)
                        # Match the full tag pattern including any suffix to avoid partial replacements
                        echo "Updating backend-deployment.yaml..."
                        sed -i -E "s|image: ${IMAGE_NAME}:${BACKEND_TAG}-[a-zA-Z0-9]+\$|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g" k8s/backend-deployment.yaml
                        
                        echo "Updating frontend-deployment.yaml..."
                        sed -i -E "s|image: ${IMAGE_NAME}:${FRONTEND_TAG}-[a-zA-Z0-9]+\$|image: ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}|g" k8s/frontend-deployment.yaml
                        
                        echo "Updating consumer-deployment.yaml..."
                        sed -i -E "s|image: ${IMAGE_NAME}:${BACKEND_TAG}-[a-zA-Z0-9]+\$|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g" k8s/consumer-deployment.yaml
                        
                        echo "Updating db-init-job.yaml..."
                        sed -i -E "s|image: ${IMAGE_NAME}:${BACKEND_TAG}-[a-zA-Z0-9]+\$|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g" k8s/db-init-job.yaml
                        
                        echo "Updated manifests with build number: ${BUILD_NUMBER}"
                        
                        # Show what changed
                        echo "=== Verification: Image tags in manifests ==="
                        grep -n "image:" k8s/backend-deployment.yaml k8s/frontend-deployment.yaml k8s/consumer-deployment.yaml k8s/db-init-job.yaml || true
                    """
                }
            }
        }

        stage('Deploy to Minikube via Ansible') {
            steps {
                script {
                    withCredentials([usernamePassword(
                        credentialsId: DOCKER_HUB_CREDENTIALS,
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {
                        sh '''#!/bin/bash
                            # Create virtual environment if it doesn't exist
                            if [ ! -d "ansible-venv" ]; then
                                echo "Creating Python virtual environment..."
                                python3 -m venv ansible-venv
                            fi
                            
                            # Activate virtual environment (using . for POSIX compatibility)
                            . ansible-venv/bin/activate
                            
                            # Get the Python path from the virtual environment
                            VENV_PYTHON=$(which python3)
                            echo "Using Python interpreter: ${VENV_PYTHON}"
                            
                            # Upgrade pip
                            pip install --upgrade pip
                            
                            # Install required packages in virtual environment
                            echo "Installing Ansible and dependencies..."
                            pip install --upgrade ansible-core kubernetes openshift pyyaml jsonpatch
                            
                            # Verify kubernetes library is installed
                            echo "Verifying Kubernetes library..."
                            python3 -c "import kubernetes; print('âœ… Kubernetes library version:', kubernetes.__version__)"
                            
                            # Install Kubernetes Ansible collection (specific compatible version)
                            echo "Installing Kubernetes collection..."
                            ansible-galaxy collection install kubernetes.core:2.4.0 --force
                            
                            # Verify Ansible version
                            ansible --version

                            echo "========================================"
                            echo " Checking Minikube status"
                            echo "========================================"
                            
                            # Check if Minikube is already running
                            if minikube status >/dev/null 2>&1; then
                                echo "âœ… Minikube is already running"
                                minikube status
                            else
                                echo "âš ï¸  Minikube is not running. Starting..."
                                minikube delete --all --purge || true
                                
                                minikube start \
                                  --driver=docker \
                                  --kubernetes-version=v1.28.0 \
                                  --memory=6144 \
                                  --cpus=4 \
                                  --wait=all
                            fi

                            # Update kubectl config from minikube
                            echo "Configuring kubectl..."
                            minikube update-context
                            
                            # Export kubeconfig for this session
                            export KUBECONFIG=~/.kube/config
                            
                            # Set kubectl context
                            kubectl config use-context minikube
                            
                            # Verify kubectl can connect
                            echo "Verifying kubectl connection..."
                            kubectl cluster-info
                            
                            echo "Waiting for Kubernetes API server to be ready..."
                            READY=0
                            for i in $(seq 1 30); do
                                if kubectl get nodes >/dev/null 2>&1; then
                                    echo "âœ… Kubernetes API server is ready."
                                    READY=1
                                    break
                                fi
                                echo "API server not ready yet (attempt $i/30)..."
                                sleep 10
                            done

                            if [ "$READY" -ne 1 ]; then
                              echo "âŒ ERROR: Kubernetes API server did not become ready in time."
                              echo "Cluster debug info:"
                              minikube status || true
                              kubectl get pods -A || true
                              exit 1
                            fi

                            echo "Cluster nodes:"
                            kubectl get nodes -o wide

                            # Verify ansible directory exists
                            if [ ! -d "ansible" ]; then
                                echo "ERROR: ansible directory not found!"
                                echo "Current directory: $(pwd)"
                                ls -la
                                exit 1
                            fi
                            
                            # Run Ansible playbook
                            echo "========================================"
                            echo " Running Ansible Deployment"
                            echo "========================================"
                            cd ansible
                            
                            # Verify playbook exists
                            if [ ! -f "playbook-with-roles.yaml" ]; then
                                echo "ERROR: playbook-with-roles.yaml not found!"
                                ls -la
                                exit 1
                            fi
                            
                            export DOCKER_USERNAME="${DOCKER_USER}"
                            export DOCKER_PASSWORD="${DOCKER_PASS}"
                            export BUILD_NUMBER="${BUILD_NUMBER}"
                            export KUBECONFIG=~/.kube/config
                            
                            # Run Ansible playbook with explicit Python interpreter
                            # This ensures Ansible uses the virtual environment's Python
                            ansible-playbook -i inventory.ini playbook-with-roles.yaml \
                                -e "docker_username=${DOCKER_USER}" \
                                -e "docker_password=${DOCKER_PASS}" \
                                -e "build_number=${BUILD_NUMBER}" \
                                -e "ansible_python_interpreter=${VENV_PYTHON}" \
                                -vv
                            
                            # Deactivate virtual environment
                            deactivate
                        '''
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    sh '''
                        echo "========================================"
                        echo "  Verifying Deployment to Minikube"
                        echo "========================================"
                        
                        # Wait for pods to be ready
                        echo ""
                        echo "â³ Waiting for backend pods..."
                        kubectl wait --for=condition=ready pod -l app=backend -n bigdata-devops --timeout=300s || echo "Backend pods not ready yet"
                        
                        echo ""
                        echo "â³ Waiting for frontend pods..."
                        kubectl wait --for=condition=ready pod -l app=frontend -n bigdata-devops --timeout=300s || echo "Frontend pods not ready yet"
                        
                        echo ""
                        echo "========================================"
                        echo "ğŸ“¦ Pods Status"
                        echo "========================================"
                        kubectl get pods -n bigdata-devops -o wide
                        
                        echo ""
                        echo "========================================"
                        echo "ğŸŒ Services Status"
                        echo "========================================"
                        kubectl get svc -n bigdata-devops
                        
                        echo ""
                        echo "========================================"
                        echo "ğŸ“Š HPA Status"
                        echo "========================================"
                        kubectl get hpa -n bigdata-devops || echo "No HPAs found"
                        
                        echo ""
                        echo "========================================"
                        echo "ğŸš€ Deployments Status"
                        echo "========================================"
                        kubectl get deployments -n bigdata-devops
                        
                        echo ""
                        echo "========================================"
                        echo "ğŸ”— Service URLs"
                        echo "========================================"
                        
                        # Get Minikube IP
                        MINIKUBE_IP=$(minikube ip)
                        
                        # Get NodePorts
                        FRONTEND_PORT=$(kubectl get svc frontend -n bigdata-devops -o jsonpath='{.spec.ports[0].nodePort}')
                        KIBANA_PORT=$(kubectl get svc kibana -n bigdata-devops -o jsonpath='{.spec.ports[0].nodePort}')
                        
                        echo "Frontend URL: http://${MINIKUBE_IP}:${FRONTEND_PORT}"
                        echo "Kibana URL: http://${MINIKUBE_IP}:${KIBANA_PORT}"
                        
                        echo ""
                        echo "Alternative access (port-forward):"
                        echo "  kubectl port-forward -n bigdata-devops svc/frontend 8501:8501"
                        echo "  kubectl port-forward -n bigdata-devops svc/kibana 5601:5601"
                        
                        echo ""
                        echo "========================================"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            script {
                sh '''
                    docker-compose -p test down -v || true
                '''
            }
        }
        success {
            echo '================================================'
            echo '  âœ… Pipeline completed successfully!'
            echo '================================================'
            echo "Build Number: ${BUILD_NUMBER}"
            echo 'Images pushed to DockerHub:'
            echo "  - ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}"
            echo "  - ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}"
            echo 'Deployed to Minikube namespace: bigdata-devops'
            echo '================================================'
            
            script {
                sh '''
                    echo ""
                    echo "ğŸŒ Access your application:"
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    
                    # Get Minikube IP and NodePorts
                    MINIKUBE_IP=$(minikube ip 2>/dev/null || echo 'Not available')
                    FRONTEND_PORT=$(kubectl get svc frontend -n bigdata-devops -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo 'N/A')
                    KIBANA_PORT=$(kubectl get svc kibana -n bigdata-devops -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo 'N/A')
                    
                    if [ "$MINIKUBE_IP" != "Not available" ] && [ "$FRONTEND_PORT" != "N/A" ]; then
                        echo "ğŸ“Š Frontend: http://${MINIKUBE_IP}:${FRONTEND_PORT}"
                    else
                        echo "ğŸ“Š Frontend: Not available"
                    fi
                    
                    if [ "$MINIKUBE_IP" != "Not available" ] && [ "$KIBANA_PORT" != "N/A" ]; then
                        echo "ğŸ“ˆ Kibana:   http://${MINIKUBE_IP}:${KIBANA_PORT}"
                    else
                        echo "ğŸ“ˆ Kibana:   Not available"
                    fi
                    
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    
                    # Show pod status
                    echo ""
                    echo "ğŸ“¦ Running Pods:"
                    kubectl get pods -n bigdata-devops --no-headers | awk '{print "  - " $1 " (" $3 ")"}'
                ''' 
            }
        }
        failure {
            echo '================================================'
            echo '  âŒ Pipeline failed!'
            echo '================================================'
            echo 'Check the logs above for error details.'
            echo "Build Number: ${BUILD_NUMBER}"
            echo '================================================'
            
            script {
                sh '''
                    echo ""
                    echo "ğŸ” Debugging information:"
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    
                    echo "Current directory: $(pwd)"
                    echo ""
                    
                    echo "Docker version:"
                    docker --version || echo "Docker not available"
                    echo ""
                    
                    echo "Docker Compose version:"
                    docker-compose --version || echo "Docker Compose not available"
                    echo ""
                    
                    echo "Kubectl version:"
                    kubectl version --client --short || echo "Kubectl not available"
                    echo ""
                    
                    echo "Minikube status:"
                    minikube status || echo "Minikube not available"
                    echo ""
                    
                    echo "Files in workspace:"
                    ls -la
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                ''' 
            }
        }
    }
}