pipeline {
    agent any
    
    triggers {
        // Poll SCM every 5 minutes for changes
        pollSCM('H/5 * * * *')
        // Or use GitHub webhook (recommended)
        // githubPush()
    }
    
    environment {
        DOCKER_HUB_CREDENTIALS = 'dockerhub-credentials'
        IMAGE_NAME = 'siddharth194/bigdata-devops'
        BACKEND_TAG = 'backend'
        FRONTEND_TAG = 'frontend'
    }
    
    stages {
        stage('Cleanup Previous') {
            steps {
                script {
                    sh '''
                        # stop compose project and prune system state
                        docker compose -p test down -v || true
                        docker system prune -af || true

                        echo "Removing old images for ${IMAGE_NAME} (frontend/backed tags)..."

                        # Remove previous frontend images: ${IMAGE_NAME}:frontend-*
                        docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' \
                          | awk -v repo="${IMAGE_NAME}" -v prefix="${FRONTEND_TAG}-" '$1 ~ (repo ":" prefix) {print $2}' \
                          | xargs -r docker rmi -f || true

                        # Remove previous backend images: ${IMAGE_NAME}:backend-*
                        docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' \
                          | awk -v repo="${IMAGE_NAME}" -v prefix="${BACKEND_TAG}-" '$1 ~ (repo ":" prefix) {print $2}' \
                          | xargs -r docker rmi -f || true

                        # Cleanup any dangling images
                        docker image prune -f || true
                    '''
                }
            }
        }
        
        stage('Checkout') {
            steps {
                git branch: 'main',
                    url: 'https://github.com/Shreyas529/BigData-DevOps.git',
                    credentialsId: 'github-credentials'
            }
        }

        stage('Run Tests') {
            steps {
                script {
                    sh '''
                        docker compose -f docker-compose.test.yml \
                            --project-name test \
                            up --build --abort-on-container-exit --exit-code-from test_runner
                    '''
                }
            }
        }

        stage('Build Images') {
            steps {
                script {
                    sh """
                        echo "Building Frontend Image..."
                        docker build -t ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER} ./frontend

                        echo "Building Backend Image..."
                        docker build -t ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER} ./backend
                    """
                }
            }
        }

        stage('Push to DockerHub') {
            steps {
                script {
                    withCredentials([usernamePassword(
                        credentialsId: DOCKER_HUB_CREDENTIALS,
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {

                        sh """
                            echo "Pushing Frontend Image..."
                            docker push ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}

                            echo "Pushing Backend Image..."
                            docker push ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}

                            docker logout
                        """
                    }
                }
            }
        }

        stage('Pull Images from DockerHub') {
            steps {
                script {
                    sh """
                        docker pull ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}
                        docker pull ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}
                    """
                }
            }
        }

        stage('Update Kubernetes Manifests') {
            steps {
                script {
                    sh """
                        # Update image tags in Kubernetes manifests
                        sed -i 's|image: ${IMAGE_NAME}:${BACKEND_TAG}-.*|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g' k8s/backend-deployment.yaml
                        sed -i 's|image: ${IMAGE_NAME}:${FRONTEND_TAG}-.*|image: ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}|g' k8s/frontend-deployment.yaml
                        sed -i 's|image: ${IMAGE_NAME}:${BACKEND_TAG}-.*|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g' k8s/consumer-deployment.yaml
                        sed -i 's|image: ${IMAGE_NAME}:${BACKEND_TAG}-.*|image: ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}|g' k8s/db-init-job.yaml
                        
                        echo "Updated manifests with build number: ${BUILD_NUMBER}"
                    """
                }
            }
        }

        stage('Deploy to Minikube via Ansible') {
            steps {
                script {
                    withCredentials([usernamePassword(
                        credentialsId: DOCKER_HUB_CREDENTIALS,
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {
                        sh """
                            # Check if Ansible is installed
                            if ! command -v ansible-playbook &> /dev/null; then
                                echo "Installing Ansible..."
                                pip3 install ansible
                            fi
                            
                            # Install Kubernetes Ansible collection
                            ansible-galaxy collection install kubernetes.core --force || true
                            
                            # Install Python Kubernetes client
                            pip3 install kubernetes openshift || true
                            
                            # Verify Minikube is running
                            if ! minikube status &> /dev/null; then
                                echo "Warning: Minikube is not running. Starting Minikube..."
                                minikube start --memory=8192 --cpus=4 || {
                                    echo "Failed to start Minikube. Please ensure Minikube is available."
                                    exit 1
                                }
                            fi
                            
                            # Set kubectl context
                            kubectl config use-context minikube || true
                            
                            # Run Ansible playbook
                            cd ansible
                            export DOCKER_USERNAME=\${DOCKER_USER}
                            export DOCKER_PASSWORD=\${DOCKER_PASS}
                            export BUILD_NUMBER=${BUILD_NUMBER}
                            
                            ansible-playbook -i inventory.ini playbook-with-roles.yaml \
                                -e "docker_username=\${DOCKER_USER}" \
                                -e "docker_password=\${DOCKER_PASS}" \
                                -e "build_number=${BUILD_NUMBER}" \
                                -v
                        """
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                script {
                    sh """
                        echo "Verifying deployment..."
                        
                        # Wait for pods to be ready
                        kubectl wait --for=condition=ready pod -l app=backend -n bigdata-devops --timeout=300s || true
                        kubectl wait --for=condition=ready pod -l app=frontend -n bigdata-devops --timeout=300s || true
                        
                        # Show deployment status
                        echo "=== Pods Status ==="
                        kubectl get pods -n bigdata-devops
                        
                        echo "=== Services Status ==="
                        kubectl get svc -n bigdata-devops
                        
                        echo "=== HPA Status ==="
                        kubectl get hpa -n bigdata-devops
                        
                        # Get service URLs
                        echo "=== Service URLs ==="
                        minikube service frontend -n bigdata-devops --url || echo "Frontend service not ready"
                        minikube service kibana -n bigdata-devops --url || echo "Kibana service not ready"
                    """
                }
            }
        }
    }
        
    //     stage('Start Test Infrastructure') {
    //         steps {
    //             script {
    //                 sh '''
    //                     # Start services with project-specific names
    //                     docker-compose -p ${COMPOSE_PROJECT_NAME} up -d postgres zookeeper kafka
                        
    //                     # Get the actual postgres container name
    //                     POSTGRES_CONTAINER=$(docker-compose -p ${COMPOSE_PROJECT_NAME} ps -q postgres)
    //                     echo "PostgreSQL container ID: ${POSTGRES_CONTAINER}"
                        
    //                     # Wait for PostgreSQL using container ID
    //                     echo "Waiting for PostgreSQL..."
    //                     timeout 60 bash -c "until docker exec ${POSTGRES_CONTAINER} pg_isready -U postgres; do sleep 2; done"
                        
    //                     # Wait for Kafka
    //                     echo "Waiting for Kafka..."
    //                     sleep 15
    //                 '''
    //             }
    //         }
    //     }
        
    //     stage('Initialize Database') {
    //         steps {
    //             script {
    //                 // Use service name 'postgres' which works within docker network
    //                 sh '''
    //                     docker run --rm \
    //                         --network ${COMPOSE_PROJECT_NAME}_devops-net \
    //                         -e POSTGRES_HOST=postgres \
    //                         -e POSTGRES_PORT=5432 \
    //                         -e POSTGRES_DB=logindata \
    //                         -e POSTGRES_USER=postgres \
    //                         -e POSTGRES_PASSWORD=pwd \
    //                         netflix-backend:${BUILD_NUMBER} \
    //                         python db_init.py
    //                 '''
    //             }
    //         }
    //     }
        
    //     stage('Run Tests') {
    //         steps {
    //             script {
    //                 // Use service name 'postgres' which works within docker network
    //                 sh '''
    //                     docker run --rm \
    //                         --network ${COMPOSE_PROJECT_NAME}_devops-net \
    //                         -e POSTGRES_HOST=postgres \
    //                         -e POSTGRES_PORT=5432 \
    //                         -e POSTGRES_DB=logindata \
    //                         -e POSTGRES_USER=postgres \
    //                         -e POSTGRES_PASSWORD=pwd \
    //                         netflix-tests:${BUILD_NUMBER}
    //                 '''
    //             }
    //         }
    //     }
        
    //     stage('Integration Test') {
    //         steps {
    //             script {
    //                 // Use service names 'kafka' and 'postgres' which work within docker network
    //                 sh '''
    //                     # Start backend with unique name
    //                     docker run -d --name backend-${BUILD_NUMBER} \
    //                         --network ${COMPOSE_PROJECT_NAME}_devops-net \
    //                         -e KAFKA_BOOTSTRAP_SERVERS=kafka:9092 \
    //                         -e KAFKA_TOPIC=login_events \
    //                         -e BACKEND_PORT=5002 \
    //                         -p 5002:5002 \
    //                         netflix-backend:${BUILD_NUMBER}
                        
    //                     # Start consumer with unique name
    //                     docker run -d --name consumer-${BUILD_NUMBER} \
    //                         --network ${COMPOSE_PROJECT_NAME}_devops-net \
    //                         -e KAFKA_BOOTSTRAP_SERVERS=kafka:9092 \
    //                         -e KAFKA_TOPIC=login_events \
    //                         -e KAFKA_GROUP_ID=login_consumer_group \
    //                         -e POSTGRES_HOST=postgres \
    //                         -e POSTGRES_PORT=5432 \
    //                         -e POSTGRES_DB=logindata \
    //                         -e POSTGRES_USER=postgres \
    //                         -e POSTGRES_PASSWORD=pwd \
    //                         netflix-backend:${BUILD_NUMBER} \
    //                         python consumer.py
                        
    //                     # Wait for services to be ready
    //                     sleep 10
                        
    //                     # Test backend health
    //                     curl -f http://localhost:5002/health || exit 1
                        
    //                     # Verify Kafka connection
    //                     docker logs backend-${BUILD_NUMBER} | grep -i "kafka" || true
    //                 '''
    //             }
    //         }
    //     }
    // }
    
    post {
        always {
            script {
                sh '''
                    docker compose -p test down -v || true
                '''
            }
        }
        success {
            echo '================================================'
            echo '  Pipeline completed successfully!'
            echo '================================================'
            echo 'Build Number: ' + env.BUILD_NUMBER
            echo 'Images pushed to DockerHub:'
            echo "  - ${IMAGE_NAME}:${BACKEND_TAG}-${BUILD_NUMBER}"
            echo "  - ${IMAGE_NAME}:${FRONTEND_TAG}-${BUILD_NUMBER}"
            echo 'Deployed to Minikube namespace: bigdata-devops'
            echo '================================================'
            
            // Get deployment URLs
            sh '''
                echo "Access your application:"
                echo "Frontend: $(minikube service frontend -n bigdata-devops --url 2>/dev/null || echo 'Not available')"
                echo "Kibana: $(minikube service kibana -n bigdata-devops --url 2>/dev/null || echo 'Not available')"
            ''' 
        }
        failure {
            echo '================================================'
            echo '  Pipeline failed!'
            echo '================================================'
            echo 'Check the logs above for error details.'
            echo 'Build Number: ' + env.BUILD_NUMBER
            echo '================================================'
        }
    }
}